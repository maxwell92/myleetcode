Milestone.
--------------

刚开始拿到题目，第一反应竟然是递归，好吧，递归其实并不是最好的想法，当时顽固地用了递归，示例测试用例还没啥问题，提交之后一个短短的串就运行超时了。

递归的思路看起来像一棵树，分别从左右两边每次缩进一个字符，再判断每个字符串里是不是有重复的，比较并得到两个分支中那个较大的返回如下：

              pwwkew
        pwwke         wwkew
    pwwk  wwke      wwke    wkew
pww wwk wwk wke   kkw wke  wke kew
...

时间复杂度是O(n * 2^n)

超时之后想了想是不是需要剪枝，因为看到里面有很多重复的测试。但没有测试，觉得思路走偏了，应该不用这么复杂，于是重新思考，应该从前往后每次探测新字符是不是在前面的字符串里一共出现过了，如果出现过，那就终止，并返回这个串的长度，如果没有，继续统计长度，直到重复或字符串终止。

这个时候思路简化了，但监测是否重复出现的时候用了挨个去比较的方式，显然，这样的算法时间复杂度是O(n^2)，毫无疑问，又遇到了超时的测试用例。

最后的方法是创建一个长为128的[]int，用来统计每个字符串里出现字符的频次，一旦超过1说明该字符已经重复了，可以终止了，这样就省去了遍历比较的烦恼。如此，时间复杂度为O(n)，最后通过所有测试用例。



